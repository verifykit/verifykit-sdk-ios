// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target arm64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name VerifyKit
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Contacts
import CoreTelephony
import Darwin
import DeveloperToolsSupport
import Foundation
import MessageUI
import SafariServices
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
@_exported import VerifyKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension VerifyKit.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: VerifyKit.PKCS5.PBKDF2.Error, b: VerifyKit.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: VerifyKit.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
extension VerifyKit.MetadataTerritory {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case codeID
    case countryCode
    case internationalPrefix
    case mainCountryForCode
    case nationalPrefix
    case nationalPrefixFormattingRule
    case nationalPrefixForParsing
    case nationalPrefixTransformRule
    case preferredExtnPrefix
    case emergency
    case fixedLine
    case generalDesc
    case mobile
    case pager
    case personalNumber
    case premiumRate
    case sharedCost
    case tollFree
    case voicemail
    case voip
    case uan
    case numberFormats
    case leadingDigits
    case availableFormats
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension VerifyKit.MetadataPhoneNumberFormat {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case pattern
    case format
    case intlFormat
    case leadingDigitsPatterns
    case nationalPrefixFormattingRule
    case nationalPrefixOptionalWhenFormatting
    case domesticCarrierCodeFormattingRule
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
}
public enum VerifyKitError : Swift.Error {
  case authorizationError
  case apiError(description: Swift.String)
  case urlSchemeError
  case cancelled
}
public enum VerifyKitEnvironment {
  case debug
  case release
  public static func == (a: VerifyKit.VerifyKitEnvironment, b: VerifyKit.VerifyKitEnvironment) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: VerifyKit.Blowfish.Error, b: VerifyKit.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any VerifyKit.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: VerifyKit.Padding) throws
  @objc deinit
}
extension VerifyKit.Blowfish : VerifyKit.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = VerifyKit.BlockModeOption
  public typealias Element = VerifyKit.BlockModeOption
  public typealias RawValue = Swift.Int
}
public struct VerifyKitOptions {
  public init(environment: VerifyKit.VerifyKitEnvironment = .debug, logActive: Swift.Bool = true, deviceID: Swift.String? = nil)
}
public protocol VerifyKitDelegate : UIKit.UIViewController {
  func didSuccess(with sessionCode: Swift.String)
  func didFail(with error: VerifyKit.VerifyKitError)
}
public protocol VerifyKitViewController : UIKit.UIViewController {
  var kitDelegate: (any VerifyKit.VerifyKitDelegate)? { get set }
}
final public class SHA2 {
  public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: VerifyKit.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: VerifyKit.SHA2.Variant.RawValue)
  }
  public init(variant: VerifyKit.SHA2.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension VerifyKit.SHA2 : VerifyKit.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
  public static let kBackToNavigate: Foundation.Notification.Name
  public static let kBackToEditPhoneNumber: Foundation.Notification.Name
  public static let kDismissEditPhoneNumber: Foundation.Notification.Name
  public static let kCloseSDK: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (VerifyKit.Reachability) -> ()
  public typealias NetworkUnreachable = (VerifyKit.Reachability) -> ()
  @available(*, unavailable, renamed: "Connection")
  public enum NetworkStatus : Swift.CustomStringConvertible, Swift.Equatable {
    case notReachable, reachableViaWiFi, reachableViaWWAN
    public var description: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: VerifyKit.Reachability.NetworkStatus, b: VerifyKit.Reachability.NetworkStatus) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    @available(*, deprecated, renamed: "unavailable")
    public static let none: VerifyKit.Reachability.Connection
    public static func == (a: VerifyKit.Reachability.Connection, b: VerifyKit.Reachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: VerifyKit.Reachability.NetworkReachable?
  public var whenUnreachable: VerifyKit.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: VerifyKit.Reachability.Connection {
    get
  }
  public var connection: VerifyKit.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension VerifyKit.Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct ECB : VerifyKit.BlockMode {
  public let options: VerifyKit.BlockModeOption
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
}
public typealias MetadataCallback = (() throws -> Foundation.Data?)
final public class PhoneNumberKit {
  public init(metadataCallback: @escaping VerifyKit.MetadataCallback = PhoneNumberKit.defaultMetadataCallback)
  final public func parse(_ numberString: Swift.String, withRegion region: Swift.String = PhoneNumberKit.defaultRegionCode(), ignoreType: Swift.Bool = false) throws -> VerifyKit.PhoneNumber
  final public func parse(_ numberStrings: [Swift.String], withRegion region: Swift.String = PhoneNumberKit.defaultRegionCode(), ignoreType: Swift.Bool = false, shouldReturnFailedEmptyNumbers: Swift.Bool = false) -> [VerifyKit.PhoneNumber]
  final public func isValidPhoneNumber(_ numberString: Swift.String, withRegion region: Swift.String = PhoneNumberKit.defaultRegionCode(), ignoreType: Swift.Bool = false) -> Swift.Bool
  final public func format(_ phoneNumber: VerifyKit.PhoneNumber, toType formatType: VerifyKit.PhoneNumberFormat, withPrefix prefix: Swift.Bool = true) -> Swift.String
  final public func allCountries() -> [Swift.String]
  final public func countries(withCode countryCode: Swift.UInt64) -> [Swift.String]?
  final public func mainCountry(forCode countryCode: Swift.UInt64) -> Swift.String?
  final public func countryCode(for country: Swift.String) -> Swift.UInt64?
  final public func leadingDigits(for country: Swift.String) -> Swift.String?
  final public func getRegionCode(of phoneNumber: VerifyKit.PhoneNumber) -> Swift.String?
  final public func getExampleNumber(forCountry countryCode: Swift.String, ofType type: VerifyKit.PhoneNumberType = .mobile) -> VerifyKit.PhoneNumber?
  final public func getFormattedExampleNumber(forCountry countryCode: Swift.String, ofType type: VerifyKit.PhoneNumberType = .mobile, withFormat format: VerifyKit.PhoneNumberFormat = .international, withPrefix prefix: Swift.Bool = true) -> Swift.String?
  final public func metadata(for country: Swift.String) -> VerifyKit.MetadataTerritory?
  final public func metadata(forCode countryCode: Swift.UInt64) -> [VerifyKit.MetadataTerritory]?
  final public func possiblePhoneNumberLengths(forCountry country: Swift.String, phoneNumberType: VerifyKit.PhoneNumberType, lengthType: VerifyKit.PossibleLengthType) -> [Swift.Int]
  final public class func defaultRegionCode() -> Swift.String
  public static func defaultMetadataCallback() throws -> Foundation.Data?
  @objc deinit
}
extension VerifyKit.PhoneNumberKit {
  public enum CountryCodePicker {
    public static var commonCountryCodes: [Swift.String]
    public static var forceModalPresentation: Swift.Bool
    public static var alwaysShowsSearchBar: Swift.Bool
  }
}
extension VerifyKit.HMAC {
  convenience public init(key: Swift.String, variant: VerifyKit.HMAC.Variant = .md5) throws
}
public protocol CheckSessionProtocol : AnyObject {
  static func checkInterruptedSession(completion: @escaping (Swift.String?) -> Swift.Void)
}
extension VerifyKit.CheckSessionProtocol {
  public static func checkInterruptedSession(completion: @escaping (Swift.String?) -> Swift.Void)
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: VerifyKit.SHA2.Variant) -> [Element]
  public func sha3(_ variant: VerifyKit.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: any VerifyKit.Cipher) throws -> [Element]
  public func decrypt(cipher: any VerifyKit.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : VerifyKit.Authenticator
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : VerifyKit.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: VerifyKit.Padding, b: VerifyKit.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct MetadataTerritory : Swift.Decodable {
  public let codeID: Swift.String
  public let countryCode: Swift.UInt64
  public let internationalPrefix: Swift.String?
  public let mainCountryForCode: Swift.Bool
  public let nationalPrefix: Swift.String?
  public let nationalPrefixFormattingRule: Swift.String?
  public let nationalPrefixForParsing: Swift.String?
  public let nationalPrefixTransformRule: Swift.String?
  public let preferredExtnPrefix: Swift.String?
  public let emergency: VerifyKit.MetadataPhoneNumberDesc?
  public let fixedLine: VerifyKit.MetadataPhoneNumberDesc?
  public let generalDesc: VerifyKit.MetadataPhoneNumberDesc?
  public let mobile: VerifyKit.MetadataPhoneNumberDesc?
  public let pager: VerifyKit.MetadataPhoneNumberDesc?
  public let personalNumber: VerifyKit.MetadataPhoneNumberDesc?
  public let premiumRate: VerifyKit.MetadataPhoneNumberDesc?
  public let sharedCost: VerifyKit.MetadataPhoneNumberDesc?
  public let tollFree: VerifyKit.MetadataPhoneNumberDesc?
  public let voicemail: VerifyKit.MetadataPhoneNumberDesc?
  public let voip: VerifyKit.MetadataPhoneNumberDesc?
  public let uan: VerifyKit.MetadataPhoneNumberDesc?
  public let numberFormats: [VerifyKit.MetadataPhoneNumberFormat]
  public let leadingDigits: Swift.String?
}
public struct MetadataPhoneNumberDesc : Swift.Decodable {
  public let exampleNumber: Swift.String?
  public let nationalNumberPattern: Swift.String?
  public let possibleNumberPattern: Swift.String?
  public let possibleLengths: VerifyKit.MetadataPossibleLengths?
  public init(from decoder: any Swift.Decoder) throws
}
public struct MetadataPossibleLengths : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
public struct MetadataPhoneNumberFormat : Swift.Decodable {
  public let pattern: Swift.String?
  public let format: Swift.String?
  public let intlFormat: Swift.String?
  public let leadingDigitsPatterns: [Swift.String]?
  public var nationalPrefixFormattingRule: Swift.String?
  public let nationalPrefixOptionalWhenFormatting: Swift.Bool?
  public let domesticCarrierCodeFormattingRule: Swift.String?
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: VerifyKit.HKDF.Error, b: VerifyKit.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: VerifyKit.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
extension VerifyKit.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: VerifyKit.PKCS5.PBKDF1.Error, b: VerifyKit.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      public static func == (a: VerifyKit.PKCS5.PBKDF1.Variant, b: VerifyKit.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: VerifyKit.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    public func calculate() -> Swift.Array<Swift.UInt8>
  }
}
public enum PhoneNumberDecodingStrategy {
  case properties
  case e164
  public static var `default`: VerifyKit.PhoneNumberDecodingStrategy
  public static func == (a: VerifyKit.PhoneNumberDecodingStrategy, b: VerifyKit.PhoneNumberDecodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PhoneNumberEncodingStrategy {
  case properties
  case e164
  public static var `default`: VerifyKit.PhoneNumberEncodingStrategy
  public static func == (a: VerifyKit.PhoneNumberEncodingStrategy, b: VerifyKit.PhoneNumberEncodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PhoneNumberDecodingUtils {
  public static var defaultPhoneNumberKit: () -> VerifyKit.PhoneNumberKit
}
public enum PhoneNumberEncodingUtils {
  public static var defaultPhoneNumberKit: () -> VerifyKit.PhoneNumberKit
}
extension Foundation.JSONDecoder {
  public var phoneNumberDecodingStrategy: VerifyKit.PhoneNumberDecodingStrategy {
    get
    set
  }
  public var phoneNumberKit: () -> VerifyKit.PhoneNumberKit {
    get
    set
  }
}
extension Foundation.JSONEncoder {
  public var phoneNumberEncodingStrategy: VerifyKit.PhoneNumberEncodingStrategy {
    get
    set
  }
  public var phoneNumberKit: () -> VerifyKit.PhoneNumberKit {
    get
    set
  }
}
extension VerifyKit.PhoneNumber : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public protocol CountryCodePickerDelegate : AnyObject {
  func countryCodePickerViewControllerDidPickCountry(_ country: VerifyKit.CountryCodePickerViewController.Country)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class CountryCodePickerViewController : UIKit.UITableViewController {
  @_Concurrency.MainActor(unsafe) final public let phoneNumberKit: VerifyKit.PhoneNumberKit
  @_Concurrency.MainActor(unsafe) final public let options: VerifyKit.CountryCodePickerOptions
  @_Concurrency.MainActor(unsafe) weak public var delegate: (any VerifyKit.CountryCodePickerDelegate)?
  @_Concurrency.MainActor(unsafe) public init(phoneNumberKit: VerifyKit.PhoneNumberKit, options: VerifyKit.CountryCodePickerOptions?, commonCountryCodes: [Swift.String] = PhoneNumberKit.CountryCodePicker.commonCountryCodes)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, titleForHeaderInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func sectionIndexTitles(for tableView: UIKit.UITableView) -> [Swift.String]?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
}
extension VerifyKit.CountryCodePickerViewController : UIKit.UISearchResultsUpdating {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func updateSearchResults(for searchController: UIKit.UISearchController)
}
extension VerifyKit.CountryCodePickerViewController {
  public struct Country {
    public var code: Swift.String
    public var flag: Swift.String
    public var name: Swift.String
    public var prefix: Swift.String
    public init?(for countryCode: Swift.String, with phoneNumberKit: VerifyKit.PhoneNumberKit)
  }
  @objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class Cell : UIKit.UITableViewCell {
    @objc deinit
  }
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension VerifyKit.MD5 : VerifyKit.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.String {
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func md5() -> Swift.String
  public func sha1() -> Swift.String
  public func sha224() -> Swift.String
  public func sha256() -> Swift.String
  public func sha384() -> Swift.String
  public func sha512() -> Swift.String
  public func sha3(_ variant: VerifyKit.SHA3.Variant) -> Swift.String
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.String
  public func encrypt(cipher: any VerifyKit.Cipher) throws -> Swift.String
  public func encryptToBase64(cipher: any VerifyKit.Cipher) throws -> Swift.String?
  public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : VerifyKit.Authenticator
}
@_inheritsConvenienceInitializers final public class CBCMAC : VerifyKit.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
final public class Poly1305 : VerifyKit.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: VerifyKit.Poly1305.Error, b: VerifyKit.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct PhoneNumber {
  public let numberString: Swift.String
  public let countryCode: Swift.UInt64
  public let leadingZero: Swift.Bool
  public let nationalNumber: Swift.UInt64
  public let numberExtension: Swift.String?
  public let type: VerifyKit.PhoneNumberType
  public let regionID: Swift.String?
}
extension VerifyKit.PhoneNumber : Swift.Equatable {
  public static func == (lhs: VerifyKit.PhoneNumber, rhs: VerifyKit.PhoneNumber) -> Swift.Bool
}
extension VerifyKit.PhoneNumber : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension VerifyKit.PhoneNumber {
  public static func notPhoneNumber() -> VerifyKit.PhoneNumber
  public func notParsed() -> Swift.Bool
  public var url: Foundation.URL? {
    get
  }
}
extension VerifyKit.PhoneNumber {
  @available(*, unavailable, message: "use PhoneNumberKit instead to produce PhoneNumbers")
  public init(rawNumber: Swift.String) throws
  @available(*, unavailable, message: "use PhoneNumberKit instead to produce PhoneNumbers")
  public init(rawNumber: Swift.String, region: Swift.String) throws
}
extension VerifyKit.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
extension VerifyKit.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: VerifyKit.Rabbit.Error, b: VerifyKit.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension VerifyKit.Rabbit : VerifyKit.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.String {
  public func decryptBase64ToString(cipher: any VerifyKit.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: any VerifyKit.Cipher) throws -> Swift.Array<Swift.UInt8>
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: VerifyKit.ChaCha20.Error, b: VerifyKit.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension VerifyKit.ChaCha20 : VerifyKit.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension VerifyKit.ChaCha20 {
  public struct ChaChaEncryptor : VerifyKit.Cryptor, VerifyKit.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension VerifyKit.ChaCha20 {
  public struct ChaChaDecryptor : VerifyKit.Cryptor, VerifyKit.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension VerifyKit.ChaCha20 : VerifyKit.Cryptors {
  final public func makeEncryptor() -> any VerifyKit.Cryptor & VerifyKit.Updatable
  final public func makeDecryptor() -> any VerifyKit.Cryptor & VerifyKit.Updatable
}
public class CMAC : VerifyKit.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: VerifyKit.CMAC.Error, b: VerifyKit.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: any VerifyKit.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public struct PCBC : VerifyKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: VerifyKit.PCBC.Error, b: VerifyKit.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: VerifyKit.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
}
public struct CountryCodePickerOptions {
  public init()
  public init(backgroundColor: UIKit.UIColor? = nil, separatorColor: UIKit.UIColor? = nil, textLabelColor: UIKit.UIColor? = nil, textLabelFont: UIKit.UIFont? = nil, detailTextLabelColor: UIKit.UIColor? = nil, detailTextLabelFont: UIKit.UIFont? = nil, tintColor: UIKit.UIColor? = nil, cellBackgroundColor: UIKit.UIColor? = nil, cellBackgroundColorSelection: UIKit.UIColor? = nil)
  public var backgroundColor: UIKit.UIColor?
  public var separatorColor: UIKit.UIColor?
  public var textLabelColor: UIKit.UIColor?
  public var textLabelFont: UIKit.UIFont?
  public var detailTextLabelColor: UIKit.UIColor?
  public var detailTextLabelFont: UIKit.UIFont?
  public var tintColor: UIKit.UIColor?
  public var cellBackgroundColor: UIKit.UIColor?
  public var cellBackgroundColorSelection: UIKit.UIColor?
}
public struct CBC : VerifyKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: VerifyKit.CBC.Error, b: VerifyKit.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: VerifyKit.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension VerifyKit.Updatable {
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public mutating func finish() throws -> Swift.Array<Swift.UInt8>
  public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
  public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
final public class VerifyKitInstance : VerifyKit.CheckSessionProtocol {
  public init()
  public init(options: VerifyKit.VerifyKitOptions)
  final public func viewControllerForLogin() -> any VerifyKit.VerifyKitViewController
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class Checksum {
  @objc deinit
}
extension VerifyKit.Checksum {
  public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String?
  public init(base64: Swift.String)
}
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: VerifyKit.CTR.Error, b: VerifyKit.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: VerifyKit.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
}
public protocol CipherModeWorker {
  var cipherOperation: VerifyKit.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : VerifyKit.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : VerifyKit.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : VerifyKit.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : VerifyKit.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : VerifyKit.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : VerifyKit.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
extension VerifyKit.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: VerifyKit.Padding = .pkcs7) throws
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum PKCS5 {
}
extension VerifyKit.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: VerifyKit.Padding = .pkcs7) throws
}
public struct CFB : VerifyKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: VerifyKit.CFB.Error, b: VerifyKit.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: VerifyKit.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
}
@objc open class PhoneNumberFormatter : Foundation.Formatter {
  final public let phoneNumberKit: VerifyKit.PhoneNumberKit
  @objc dynamic public var generatesPhoneNumber: Swift.Bool
  @objc dynamic public var defaultRegion: Swift.String {
    @objc get
    @objc set
  }
  @objc dynamic public var withPrefix: Swift.Bool {
    @objc get
    @objc set
  }
  @objc dynamic public var currentRegion: Swift.String {
    @objc get
  }
  public init(phoneNumberKit pnk: VerifyKit.PhoneNumberKit = PhoneNumberKit(), defaultRegion: Swift.String = PhoneNumberKit.defaultRegionCode(), withPrefix: Swift.Bool = true)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension VerifyKit.PhoneNumberFormatter {
  @objc override dynamic open func string(for obj: Any?) -> Swift.String?
  @objc override dynamic open func getObjectValue(_ obj: Swift.AutoreleasingUnsafeMutablePointer<Swift.AnyObject?>?, for string: Swift.String, errorDescription error: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSString?>?) -> Swift.Bool
  @objc override dynamic open func isPartialStringValid(_ partialStringPtr: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSString>, proposedSelectedRange proposedSelRangePtr: Foundation.NSRangePointer?, originalString origString: Swift.String, originalSelectedRange origSelRange: Foundation.NSRange, errorDescription error: Swift.AutoreleasingUnsafeMutablePointer<Foundation.NSString?>?) -> Swift.Bool
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: VerifyKit.AES.Error, b: VerifyKit.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: VerifyKit.AES.Variant
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any VerifyKit.BlockMode, padding: VerifyKit.Padding = .pkcs7) throws
  @objc deinit
}
extension VerifyKit.AES : VerifyKit.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension VerifyKit.PhoneNumber {
  public func adjustedNationalNumber() -> Swift.String
}
public struct OFB : VerifyKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: VerifyKit.OFB.Error, b: VerifyKit.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: VerifyKit.BlockModeOption
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
}
@available(*, renamed: "Digest")
public typealias Hash = VerifyKit.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: VerifyKit.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: VerifyKit.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : VerifyKit.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
extension UIKit.UIFont {
  public static let loadAllFonts: ()
}
final public class SHA1 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension VerifyKit.SHA1 : VerifyKit.Updatable {
  @discardableResult
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
final public class GCM : VerifyKit.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: VerifyKit.GCM.Mode, b: VerifyKit.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: VerifyKit.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: VerifyKit.GCM.Error, b: VerifyKit.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: VerifyKit.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: VerifyKit.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
  @objc deinit
}
@_hasMissingDesignatedInitializers public class BlockDecryptor : VerifyKit.Cryptor, VerifyKit.Updatable {
  public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: VerifyKit.BlockModeOption { get }
  func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: VerifyKit.CCM.Error, b: VerifyKit.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: VerifyKit.BlockModeOption
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: VerifyKit.SHA3.Variant, b: VerifyKit.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: VerifyKit.SHA3.Variant)
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension VerifyKit.SHA3 : VerifyKit.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
final public class OCB : VerifyKit.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: VerifyKit.OCB.Mode, b: VerifyKit.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: VerifyKit.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: VerifyKit.OCB.Error, b: VerifyKit.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: VerifyKit.OCB.Mode = .detached)
  convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: VerifyKit.OCB.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping VerifyKit.CipherOperationOnBlock, encryptionOperation: @escaping VerifyKit.CipherOperationOnBlock) throws -> any VerifyKit.CipherModeWorker
  @objc deinit
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: VerifyKit.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: any VerifyKit.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: any VerifyKit.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: any VerifyKit.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
@_hasMissingDesignatedInitializers final public class PartialFormatter {
  convenience public init(phoneNumberKit: VerifyKit.PhoneNumberKit = PhoneNumberKit(), defaultRegion: Swift.String = PhoneNumberKit.defaultRegionCode(), withPrefix: Swift.Bool = true, maxDigits: Swift.Int? = nil, ignoreIntlNumbers: Swift.Bool = false)
  final public var defaultRegion: Swift.String {
    get
    set
  }
  final public var maxDigits: Swift.Int?
  final public var currentRegion: Swift.String {
    get
  }
  final public func nationalNumber(from rawNumber: Swift.String) -> Swift.String
  final public func formatPartial(_ rawNumber: Swift.String) -> Swift.String
  @objc deinit
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: VerifyKit.CipherError, b: VerifyKit.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension VerifyKit.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
final public class HMAC : VerifyKit.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: VerifyKit.HMAC.Error, b: VerifyKit.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: VerifyKit.HMAC.Variant, b: VerifyKit.HMAC.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: VerifyKit.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public enum PhoneNumberError : Swift.Error, Swift.Equatable {
  case generalError
  case invalidCountryCode
  case invalidNumber
  case tooLong
  case tooShort
  case deprecated
  case metadataNotFound
  case ambiguousNumber(phoneNumbers: Swift.Set<VerifyKit.PhoneNumber>)
  public static func == (a: VerifyKit.PhoneNumberError, b: VerifyKit.PhoneNumberError) -> Swift.Bool
}
extension VerifyKit.PhoneNumberError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum PhoneNumberFormat {
  case e164
  case international
  case national
  public static func == (a: VerifyKit.PhoneNumberFormat, b: VerifyKit.PhoneNumberFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PhoneNumberType : Swift.String, Swift.Codable {
  case fixedLine
  case mobile
  case fixedOrMobile
  case pager
  case personalNumber
  case premiumRate
  case sharedCost
  case tollFree
  case voicemail
  case voip
  case uan
  case unknown
  case notParsed
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum PossibleLengthType : Swift.String, Swift.Codable {
  case national
  case localOnly
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : VerifyKit._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [VerifyKit.Bit]
  public func bits() -> Swift.String
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class PhoneNumberTextField : UIKit.UITextField, UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) final public let phoneNumberKit: VerifyKit.PhoneNumberKit
  @_Concurrency.MainActor(unsafe) public var flagButton: UIKit.UIButton {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var text: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open func setTextUnformatted(newValue: Swift.String?)
  @_Concurrency.MainActor(unsafe) open var defaultRegion: Swift.String {
    get
    @available(*, deprecated, message: "    The setter of defaultRegion is deprecated,\n    please override defaultRegion in a subclass instead.")
    set
  }
  @_Concurrency.MainActor(unsafe) public var withPrefix: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var withFlag: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var withExamplePlaceholder: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var countryCodePlaceholderColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var numberPlaceholderColor: UIKit.UIColor {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var withDefaultPickerUI: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var withDefaultPickerUIOptions: VerifyKit.CountryCodePickerOptions
  @_Concurrency.MainActor(unsafe) public var modalPresentationStyle: UIKit.UIModalPresentationStyle?
  @_Concurrency.MainActor(unsafe) public var isPartialFormatterEnabled: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var maxDigits: Swift.Int? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var partialFormatter: VerifyKit.PartialFormatter {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var delegate: (any UIKit.UITextFieldDelegate)? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) public var currentRegion: Swift.String {
    get
  }
  @_Concurrency.MainActor(unsafe) public var nationalNumber: Swift.String {
    get
  }
  @_Concurrency.MainActor(unsafe) public var isValidNumber: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var phoneNumber: VerifyKit.PhoneNumber? {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) convenience public init(withPhoneNumberKit phoneNumberKit: VerifyKit.PhoneNumberKit)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, phoneNumberKit: VerifyKit.PhoneNumberKit)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) public init(insets: UIKit.UIEdgeInsets, clearButtonPadding: CoreFoundation.CGFloat)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func updateFlag()
  @_Concurrency.MainActor(unsafe) open func updatePlaceholder()
  @_Concurrency.MainActor(unsafe) @objc open func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc open func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc open func textFieldDidEndEditing(_ textField: UIKit.UITextField, reason: UIKit.UITextField.DidEndEditingReason)
  @_Concurrency.MainActor(unsafe) @objc open func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc open func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
  @available(iOS 13.0, tvOS 13.0, *)
  @_Concurrency.MainActor(unsafe) @objc open func textFieldDidChangeSelection(_ textField: UIKit.UITextField)
  @objc deinit
}
extension VerifyKit.PhoneNumberTextField : VerifyKit.CountryCodePickerDelegate {
  @_Concurrency.MainActor(unsafe) public func countryCodePickerViewControllerDidPickCountry(_ country: VerifyKit.CountryCodePickerViewController.Country)
}
extension VerifyKit.PhoneNumberTextField {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func textRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func editingRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func clearButtonRect(forBounds bounds: CoreFoundation.CGRect) -> CoreFoundation.CGRect
}
public enum PKCS7 {
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> any VerifyKit.Cryptor & VerifyKit.Updatable
  func makeDecryptor() throws -> any VerifyKit.Cryptor & VerifyKit.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension VerifyKit.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension VerifyKit.AES : VerifyKit.Cryptors {
  final public func makeEncryptor() throws -> any VerifyKit.Cryptor & VerifyKit.Updatable
  final public func makeDecryptor() throws -> any VerifyKit.Cryptor & VerifyKit.Updatable
}
extension VerifyKit.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension VerifyKit.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension VerifyKit.MetadataTerritory.CodingKeys : Swift.Equatable {}
extension VerifyKit.MetadataTerritory.CodingKeys : Swift.Hashable {}
extension VerifyKit.MetadataTerritory.CodingKeys : Swift.RawRepresentable {}
extension VerifyKit.MetadataPhoneNumberFormat.CodingKeys : Swift.Equatable {}
extension VerifyKit.MetadataPhoneNumberFormat.CodingKeys : Swift.Hashable {}
extension VerifyKit.MetadataPhoneNumberFormat.CodingKeys : Swift.RawRepresentable {}
extension VerifyKit.VerifyKitEnvironment : Swift.Equatable {}
extension VerifyKit.VerifyKitEnvironment : Swift.Hashable {}
extension VerifyKit.Blowfish.Error : Swift.Equatable {}
extension VerifyKit.Blowfish.Error : Swift.Hashable {}
extension VerifyKit.SHA2.Variant : Swift.Equatable {}
extension VerifyKit.SHA2.Variant : Swift.Hashable {}
@available(*, unavailable, renamed: "Connection")
extension VerifyKit.Reachability.NetworkStatus : Swift.Hashable {}
extension VerifyKit.Reachability.Connection : Swift.Equatable {}
extension VerifyKit.Reachability.Connection : Swift.Hashable {}
extension VerifyKit.Padding : Swift.Equatable {}
extension VerifyKit.Padding : Swift.Hashable {}
extension VerifyKit.HKDF.Error : Swift.Equatable {}
extension VerifyKit.HKDF.Error : Swift.Hashable {}
extension VerifyKit.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension VerifyKit.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension VerifyKit.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension VerifyKit.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension VerifyKit.PhoneNumberDecodingStrategy : Swift.Equatable {}
extension VerifyKit.PhoneNumberDecodingStrategy : Swift.Hashable {}
extension VerifyKit.PhoneNumberEncodingStrategy : Swift.Equatable {}
extension VerifyKit.PhoneNumberEncodingStrategy : Swift.Hashable {}
extension VerifyKit.Poly1305.Error : Swift.Equatable {}
extension VerifyKit.Poly1305.Error : Swift.Hashable {}
extension VerifyKit.Rabbit.Error : Swift.Equatable {}
extension VerifyKit.Rabbit.Error : Swift.Hashable {}
extension VerifyKit.ChaCha20.Error : Swift.Equatable {}
extension VerifyKit.ChaCha20.Error : Swift.Hashable {}
extension VerifyKit.CMAC.Error : Swift.Equatable {}
extension VerifyKit.CMAC.Error : Swift.Hashable {}
extension VerifyKit.PCBC.Error : Swift.Equatable {}
extension VerifyKit.PCBC.Error : Swift.Hashable {}
extension VerifyKit.CBC.Error : Swift.Equatable {}
extension VerifyKit.CBC.Error : Swift.Hashable {}
extension VerifyKit.CTR : VerifyKit.BlockMode {}
extension VerifyKit.CTR.Error : Swift.Equatable {}
extension VerifyKit.CTR.Error : Swift.Hashable {}
extension VerifyKit.Bit : Swift.Equatable {}
extension VerifyKit.Bit : Swift.Hashable {}
extension VerifyKit.Bit : Swift.RawRepresentable {}
extension VerifyKit.CFB.Error : Swift.Equatable {}
extension VerifyKit.CFB.Error : Swift.Hashable {}
extension VerifyKit.AES.Error : Swift.Equatable {}
extension VerifyKit.AES.Error : Swift.Hashable {}
extension VerifyKit.AES.Variant : Swift.Equatable {}
extension VerifyKit.AES.Variant : Swift.Hashable {}
extension VerifyKit.AES.Variant : Swift.RawRepresentable {}
extension VerifyKit.OFB.Error : Swift.Equatable {}
extension VerifyKit.OFB.Error : Swift.Hashable {}
extension VerifyKit.GCM.Mode : Swift.Equatable {}
extension VerifyKit.GCM.Mode : Swift.Hashable {}
extension VerifyKit.GCM.Error : Swift.Equatable {}
extension VerifyKit.GCM.Error : Swift.Hashable {}
extension VerifyKit.CCM : VerifyKit.BlockMode {}
extension VerifyKit.CCM.Error : Swift.Equatable {}
extension VerifyKit.CCM.Error : Swift.Hashable {}
extension VerifyKit.SHA3.Variant : Swift.Equatable {}
extension VerifyKit.SHA3.Variant : Swift.Hashable {}
extension VerifyKit.OCB.Mode : Swift.Equatable {}
extension VerifyKit.OCB.Mode : Swift.Hashable {}
extension VerifyKit.OCB.Error : Swift.Equatable {}
extension VerifyKit.OCB.Error : Swift.Hashable {}
extension VerifyKit.CipherError : Swift.Equatable {}
extension VerifyKit.CipherError : Swift.Hashable {}
extension VerifyKit.HMAC.Error : Swift.Equatable {}
extension VerifyKit.HMAC.Error : Swift.Hashable {}
extension VerifyKit.HMAC.Variant : Swift.Equatable {}
extension VerifyKit.HMAC.Variant : Swift.Hashable {}
extension VerifyKit.PhoneNumberFormat : Swift.Equatable {}
extension VerifyKit.PhoneNumberFormat : Swift.Hashable {}
extension VerifyKit.PhoneNumberType : Swift.Equatable {}
extension VerifyKit.PhoneNumberType : Swift.Hashable {}
extension VerifyKit.PhoneNumberType : Swift.RawRepresentable {}
extension VerifyKit.PossibleLengthType : Swift.Equatable {}
extension VerifyKit.PossibleLengthType : Swift.Hashable {}
extension VerifyKit.PossibleLengthType : Swift.RawRepresentable {}
